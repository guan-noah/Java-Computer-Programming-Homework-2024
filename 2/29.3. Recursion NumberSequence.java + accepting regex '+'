//NumberSequence.java
/* Noah Guan
 * 11-15-2024
 * Per. 6 Java w/ Mr. Yu
 * NumberSequence.java
 * Program #29 
 * comment/indent guide: if comments are on the same indent (no indent) before a chunk of code, it's explaining the chunk of code. 
 *  if comments are on the same line as the code, they're explaining that line. if I need to continue something on the next line, I will indent it 1 tab from the original line. 
 * 
 * Output: 
 * 		input example: batman 7. 
 * 		It was not batman 7. It was add 2. 
 * plus, add, increase by, increment by, + 
 * 
 * Pseudocode Notes: 
 * 
 * Working on: Completing the darn code. 
 * 
 * Testing: 
 * 
 * progress: 
 * work on multiple rounds and errors (?)
 * finish userQNS method 
 * work on second half of program 
 * work on try again 
 * control-f "if the user is close" for formatting example 
 * 
 * 	
 * 
 * took out: 
 * user quit number section 
 * user encouraging messages 
*/
import java.util.Scanner;
class Main 
{
	//declare field variables
	private int sequenceRule;
	    //the incrementing rule (rule that determines how to get to the next number)
	private String userResponse;
	    //this will be the combination of 1st and 2nd part of the user response 
	
	public Main()//initialize field variables 
	{
        sequenceRule = 0;
        userResponse = "";
	}
	public static void main(String[] args)
	{
		Main ns = new Main();
			//make a new instance of numbersequence
		ns.play();
	}
	public void play()
	{
		System.out.println("\n\n\n");
			//prints the required 3 new lines 
		run();
			//call play to run the code 
		System.out.println("\n\n\n");
			//prints the required 3 new lines 
	}
	public void run() //this method runs the program. 
	{
		Scanner keyboard = new Scanner(System.in);
		prompt();
            //prints prompt 
		tries(1, getSequence());
            //gives in 1 for tries and the number answer for the first try 
            //this "tries" method is for guessing the number 
		//section on user playing again! :D
		//keep these commented out for now until first part works
		/*
		boolean done = false;
            //to see if the user's done with the whole program; initialize to user's not done with program
		if (!done)
		{
			run();
                //run the program again 
			//timesPlayed++;
                //increase the times played by 1 
		}
		else if (done)
		{
			System.out.print("Would you like to play again? [Yes/No] \t");
			String userPlayAgain = keyboard.next();
			if (userPlayAgain.equalsIgnoreCase("yes"))
			{
                run();
			}
			else if (userPlayAgain.equalsIgnoreCase("no"))
			{
                System.out.println("Alright. Thank you for playing NumberSequence! ");
			}
			else //user didn't follow directions 
			{
                System.out.println("Invalid answer response. If you would like to play again, please restart the program.");
            }
		}
		*/
	}
	public void prompt()
	{
		System.out.println("Welcome to NumberSequence.java! ");
            //welcome message
		System.out.println("\nThis program will print out a number sequence;"
			+ " you will have to find the number that comes next (the number"
			+ " in the underscore. \nYou will get at most 3 tries to guess the next"
			+ " number; after that, you will get one try to guess the rule"
			+ " for the sequence, whether you guessed the first number or not. ");
			//explains the game 
    }
    public void tries(int userTriesIn, int numAnswerIn)
        //this method is for the user's 3 chances; acts kind of like a do-while loop because the check is at the end
        //within this, calls first half of the program (guessing the number)
        //this program runs nextNumProblem, and calls sequenceProblem if ready 
	{
        boolean userCorrect;
		userCorrect = nextNumProblem(numAnswerIn);
                //we need to keep the number answer 
        
        if(!userCorrect && userTriesIn <= 3)
            //if user didn't guess correctly and has more tries 
        {
            tries(++userTriesIn, numAnswerIn);
                //give another chance 
        }
        else //user needs to continue on to the game; only 2 scenarios at this point: user succeeded or user failed. 
        {
            if (userTriesIn >= 3 && !userCorrect)
                //if user used up all the tries and didn't guess it correctly (user failed)
            {
                System.out.println("None of the guesses were correct. ");
            }
            else if (userTriesIn <= 3 || userCorrect)
                //if user used up the allotted amount of tries (or lower) or if user guessed it correctly (if user succeeded)
            {
                if (userCorrect)
                    //first option: user guessed correctly 
                {
                    if (userTriesIn == 1)
                        //if the user gets it correct on the first try,
                    {
                        System.out.println("Wow! You got it correct on the first try! ");
                    }
                    else if (userTriesIn == 2)
                        //if the user gets it correct on the second try,
                    {
                        System.out.println("Nice! You got the answer correct on the second try! ");
                    }
                    else if (userTriesIn == 3)
                        //if the user gets it correct on the third (and final) try,
                    {
                        System.out.println("Whew. You got the answer correct on the last try. ");
                    }
                }
            }
            sequenceProblem(); 
                //continue on with the game
		}
	}
	public boolean nextNumProblem(int numAnswerIn)
	    //method to run nextNum section 
	{
        int userNum = getNextNum(); 
            //get the next number from user
        boolean userCorrect = decideIfNumCorrect(numAnswerIn, userNum);
            //decide if the user number inputted is correct 
            //also prints out resulting decision from this method
		return userCorrect; 
	}
	public int getNextNum()
	{
		Scanner keyboard = new Scanner(System.in);
		System.out.print("What's the next number?\t");
		int getUserNum = keyboard.nextInt();
		return getUserNum;
	}
	public int getSequence()
        //while generating and printing sequence, this method also returns number answer 
	{
		//1st half of method: generate sequence
		int startNum = (int)(Math.random()*21 - 10);
			//this is 21 because it includes -10 to 0, 0 included (-10 to 10)
		sequenceRule = (int)(Math.random()*10 + 1);
            //this is the 10 different types of increment allotted (1 to 10)
		
		//2nd half of method: print sequence, and numAnswer 
		System.out.println("Your sequence is:");
		int numAnswerReturn = outputSequence(0, startNum);
		System.out.println("___");
		return numAnswerReturn;
	}
	public int outputSequence(int countIn, int startNumIn)
        //this method takes in the count (how many numbers outputted), the sequence rule generated, and the starting number 
        //and returns the number answer 
	{
		if (countIn < 5)//print 5 numbers to start out 
		{
			System.out.print((sequenceRule*countIn+startNumIn) + ", ");
                //print the current number
			return outputSequence(++countIn, startNumIn);
                //run the method again to print the next number 
		}
		else
		{
			int generateNumAnswer = sequenceRule*countIn+startNumIn;
			return generateNumAnswer;
		}
	}
	public boolean decideIfNumCorrect(int numAnswerIn, int userNumIn)
		//takes in the answer and the user input and returns if user correct (also prints it out to the screen)
	{
		boolean userCorrect;
			//initialized based on if user is correct or not 
		if (numAnswerIn == userNumIn)
		{
			userCorrect = true;
            System.out.println("Correct! Well done. ");
		}
		else if (Math.abs(numAnswerIn - userNumIn) < sequenceRule)
			//if the user answer is near the generated answer (max: 
			//increment distance away); basically, if the user is close 
		{
			System.out.println("Close! ");
			userCorrect = false;
		}
		else 
		{
			System.out.println("Not quite! ");
			userCorrect = false;
		}
		return userCorrect;
	}
	//leave some space for organization, separating next number problem from sequence problem 
	
	
	
	
	
	
	
	
	public void sequenceProblem()
        //problem: how to get sequenceRule into this method 
	{
		double userRule = getRule();
		boolean userResponseFormat = true;
            //good format = true; bad format = false
		if (userRule == 0.5)//the code number; user 
		{
            userResponseFormat = false;
                //bad format; userRule != sequenceRule 
            System.out.println("Your input, '" + userResponse + "' was not accepted. ");
		}
		if (sequenceRule == userRule)
		{
		    System.out.println("Correct! Congratulations! The pattern was " + userResponse +" " + sequenceRule + ". ");
		}
		else //if (sequenceRule != userRule)
		{
		    System.out.print("Sorry, your answer was incorrect. The pattern was ");
		    if (userResponseFormat) //good format
		    {
		        System.out.println(userResponse + sequenceRule);
		    }
		    else //user response was incorrect, default to "increment by"
		    {
		        System.out.println("increment by " + sequenceRule);
		    }
		}
	}
	public double getRule()
	{
		String userResponse1 = "";
            //this will be the first word the user inputs
		String userResponse2 = "";
            //this will be the second word the user inputs
		userResponse = "";
            //as stated before, this will be the combination of 1st and 2nd part of the user response 
		double userSNR;
            // to return the "user's sequence (pattern) number response", shortened to userSNR. 
		Scanner keyboard = new Scanner(System.in);
            //new instance of Scanner 
		System.out.print("How do you go from one number to the next?\t");
            //prompt user
		userResponse1 = "" + keyboard.findInLine("\\+");
		    //this "findInLine()" method is something I had to incorporate to get the '+' regex operator to work as well, even though we technically haven't learned it in class yet. 
		if (userResponse1.equalsIgnoreCase("+"))
		{
		    userResponse = userResponse1;
		}
		else //user didn't use single operator 
		{
            userResponse1 = keyboard.next();
		}
		//plus, add, increase by, increment by, + 
		//doesn't have to check for the single word keywords because it checks for everything later 
		if (userResponse.equalsIgnoreCase("increase")|| 
			userResponse.equalsIgnoreCase("increment"))
			//checks for the 2-word keywords
		{
			userResponse2 = keyboard.next();
			    //if there are, takes the second word 
		}
		userResponse = userResponse1 + userResponse2;
            //adds first word to second word; this will not throw an error if there isn't a second word because the second word is initialized to an empty string 
		if (userResponse.equalsIgnoreCase("increase by") || userResponse.equalsIgnoreCase("increment by") || userResponse.equalsIgnoreCase("add") || userResponse.equalsIgnoreCase("plus") || userResponse.equalsIgnoreCase("+"))
            //the only 4 word responses that work in addition to the "+" sign 
		{
            userSNR = keyboard.nextDouble();
                //accept the user answer
            return userSNR;
                //returns only the double value 
		}
		else
		{
		    //I would use this structure: 
            //System.out.println("Invalid response. Please try again, using \"add ___\", \"plus ___\", \"increase by ___\", or \"increment by ___\". ");
            //getRule();
            return 0.5; //code number for incorrect response
		}
	}
	/*
	//would have used this if I could have figured out how to convert a string with multiple ints to its value 
	public int singleStringToInt(String stringIn)
	{
        char toChar = stringIn.charAt(0);
        int toInt = (int)(toChar) - 48;
        return toInt;
	}
	public String intToString(int intIn);
	{
        String toString = "" + intIn;
        return toString;
	}
	*/
}
